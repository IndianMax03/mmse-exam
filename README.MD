# Расписанные билеты по дисциплине "Методы и средства программной инженерии"

[Сайт se.ifmo](https://se.ifmo.ru/courses/software-engineering-basics)

[Конспект лекций pdf](lectures-notes/Lectures.pdf)

[Видео лекций youtube](https://www.youtube.com/playlist?list=PLBWafxh1dFuykoWaAt7HiMOGgWXRvAN5V)

[Вопросы к экзамену pdf](questions/ExamQuestions.pdf)

> ### Автор
> Тучков Максим Русланович

## Билет №1

ISO/IEC 12207:2010 - Стандарт, описывающий процессы жизненного цикла программных систем

Жизненный цикл ПО - процесс развития ПО, начиная с фазы определения требований и заканчивая выводов из эксплуатации. 
Всего выделяется 8 этапов ЖЦ ПО:
1) Определение требований
2) Проектирование 
3) Анализ 
4) Разработка
5) Тестирование 
6) Ввод в эксплуатацию 
7) Эксплуатация 
8) Вывод из эксплуатации


Каждый этап жизненного цикла ПО состоит из процессов. Выделяется 7 основных групп процессов ЖЦ ПО:
1) Согласование 
2) Организационное обеспечение
3) Процессы проектов
4) Технические процессы
5) Реализация ПС
6) Поддержка ПС
7) Повторное использование ПС

![img_3.png](img_3.png)

## Билет №2

![img_2.png](img_2.png)

## Билет №3

![waterfall_model.png](waterfall_model.png)

## Билет №4

![Royce_metodologic.png](Royce_metodologic.png)

## Билет №5

![img_4.png](img_4.png)

## Билет №6

![img_5.png](img_5.png)

## Билет №7

![img_6.png](img_6.png)

## Билет №8

![img_7.png](img_7.png)

1) Планирование — совокупность требований, полученных при системном планировании и анализе процедуры разработки жизненного цикла. На этом этапе пользователи, менеджеры и IT-специалисты обсуждают задачи проекта, его объём, системные требования, а также сложности, которые могут возникнуть при разработке. Фаза завершается согласованием ключевых моментов с RAD-группой и получением от руководителей проекта разрешения на продолжение.
2) Пользовательское проектирование — на протяжении данного этапа пользователи, взаимодействуя с системными аналитиками, разрабатывают модели и прототипы, которые включают в себя все необходимые системные функции. Пользовательское проектирование оказывается длительным интерактивным процессом, который позволяет пользователям понять, изменить и в конечном счёте выбрать рабочую модель, отвечающую их требованиям.
3) Конструирование — этап, в котором основная задача заключается в разработке программ и приложений. В RAD, однако, пользователи продолжают принимать участие и по-прежнему могут предлагать изменения или улучшения в виде разработанных ими докладов. В их задачи входит программирование и разработка приложений, написание кода, интеграция модулей и системное тестирование.
4) Переключение — включает в себя операции по конверсии данных, тестирование, переход на новую систему и тренировку пользователей. Сравнивая с традиционными методами разработки ПО, весь процесс оказывается сжатым по времени. Как результат, новая система оказывается быстрее построенной, доставленной до заказчика и установленной на рабочих местах.

## Билет №9

![img_8.png](img_8.png)

## Билет №10

![img_10.png](img_10.png)

![img_11.png](img_11.png)

![img_12.png](img_12.png)

![img_13.png](img_13.png)

![img_14.png](img_14.png)

![img_15.png](img_15.png)

## Билет №11

Диаграмма вариантов использования (UseCase-диаграмма) - диаграмма, отображающая взаимодействие между вариантами использования (функциями системы) и действующими лицами (люди или системы, получающие или передающие информацию в данную систему). 
Диаграмма описывает общую функциональность системы.

Основные элементы:
### Вариант использования
![img_16.png](img_16.png)
### Актор
![img_17.png](img_17.png)
### Интерфейс
![img_18.png](img_18.png)
![img_19.png](img_19.png)
### Примечание
![img_20.png](img_20.png)
![img_21.png](img_21.png)

## Билет №12

В зависимости от уровня, диаграмма классов:
1) На уровне анализа в виде доменной модели - описание предметной области, типы классов системы и различного рода статические связи, которые существуют между ними (без деталей реализации).
2) На уровне проектирования - иллюстрирует архитектурные механизмы с деталями реализации

Диаграмма может уточняться и расширяться в дальнейшем. 

Основные элементы:
1) Имя класса
2) Атрибуты класса
3) Операции класса

![img.png](img.png)

## Билет №13

Диаграммы последовательностей используются для уточнения диаграмм прецедентов, более детального описания логики сценариев использования.

Диаграммы последовательностей обычно содержат объекты, которые взаимодействуют в рамках сценария, сообщения, которыми они обмениваются, и возвращаемые результаты, связанные с сообщениями.

Основные элементы:
1) Объекты
2) Сообщения
3) Возвращаемые результаты

Прямоугольники на вертикальных линиях под каждым из объектов показывают “время жизни” (фокус) объектов.

![img_1.png](img_1.png)

## Билет №14

Диаграмма размещения - диаграмма, показывающая физическую архитектуру размещения частей приложения на аппаратных компонентах

Основные элементы:
### Узлы
Физическая сущность, которая выполняет одну или несколько компонентов, подсистем или исполняемых файлов. Узел может быть аппаратным или программным элементом.
![img_22.png](img_22.png)

### Артефакты
Конкретные элементы, которые вызваны процессом разработки.
![img_23.png](img_23.png)

### Устройство
Узел, который используется для представления физического вычислительного ресурса в системе.
![img_24.png](img_24.png)

### Спецификация развертывания
Файл конфигурации, например текстовый файл или XML-документ. В нем описывается, как артефакт развертывается на узле.
![img_25.png](img_25.png)

## Билет №15

*UP методологии - семейство методологий, основанных на моделировании программных систем. 
Отличительной чертой является адаптация процесса разработки под требования и доступные ресурсы.


RUP - процесс разработки, основанный на инкрементально-эволюционном процессе разработки. 
Весь процесс разбит на фазы:
1) Фаза начала
2) Фаза проектирования
3) Фаза создания продукта
4) Фаза внедрения

Любая фаза заканчивается вехой - принятием решения о дальнейшем переходе в новую фазу или дополнительных работах.
Решение о переходе на новую фазу принимает стейкхолдер - заинтересованное в создании ПО лицо. 

Каждый процесс включает в себя дисциплины - набор правил и указаний для решения задачи этапа разработки ПО.

RUP имеет чуткую структуру процесса разработки, где каждому процессу соответствует роль.

Роль - группа обязанностей, которую берет участвующий в разработке для выполнения своей деятельности.
(пример - создание кода, получение заданий и т.д.)
Деятельность - процесс по выполнению задач, входным и конечным результатами которой является создание, использование и модификация артефактов.
Артефакт - результат деятельности.

Любая деятельность задается и ограничивается правилами и средствами, принятыми в компании. Для большей эффективности правила могут изменяться и дополняться, т.к. главный критерий - эффективность и реализация требований заказчика на должном уровне качества.

Отдельно отмечается важность компонентного подхода, ранней разработке архитектуры и обеспечению ее стабильности, тесного сотрудничества разработчиков и заказчиков. 

## Билет №16

На этапе происходит оценка необходимых ресурсов и времени, рисков и инструментов. 

Цели:
1) Определение границ ПО, решаемых им задач
2) Разработка и описание сценариев использования
3) Предложение технических решений
4) Подсчет стоимости и графика разработки
5) Оценка рисков и подготовка окружения разработки

Веха - Lifecycle Objects: согласие по срокам, стоимости, требованиям и т.д.

## Билет №17

На этапе происходит разработка и тестирование стабильной версии архитектуры, создание прототипов.

Цели:
1) Финализация базовой архитектуры
2) Создание прототипа как обкатки архитектуры
3) Убедиться в стабильности критериев прошлого этапа
4) Тестирование и демонстрация архитектуры 

Веха - Lifecycle Architecture: соблюдение критериев прошлой вехи, контроль и планирование ресурсов для следующих этапов

## Билет №18

На этапе происходит разработка ПО

Цели:
1) Быстрая разработка качественного продукта
2) Анализ, тестирование продукта, разработка выпусков
3) Подготовка продукта к выпуску

Веха - Initial Operational Capability: решение о внедрении продукта на стороне заказчика, проверка затрат

## Билет №19

На этапе происходит подготовка к внедрению продукта 

Цели:
1) Проведение различных финальных и пользовательских тестирований
2) Обучение пользователей и персонала
3) Запуск маркетинга и продаж
4) Отладка процессов обновления и устранения сбоев
5) Анализ соответствия планируемого и полученного продукта, расходов

Веха - Product Release: удовлетворены ли пользователи, работа над ошибками, оценка затрат на разработку

## Билет №20

Agile манифест - набор правил, декларирующий принципы гибкой методологии разработки ПО.

Главной предпосылкой появления стали постоянные изменения бизнес-требований.

Состоит из 4 ценностей и 12 принципов

### Ценности:
1) Люди и взаимодействие важнее процессов и инструментов
2) Работающий продукт важнее исчерпывающей документации
3) Сотрудничество с заказчиком важнее согласования условий контракта
4) Готовность к изменениям важнее следования первоначальному плану

### Принципы:
1) Удовлетворение требований заказчика
2) Изменение требований приветствуется
3) Частые релизы ПО
4) Совместная работа
5) Мотивированные профессионалы
6) Непосредственное общение
7) Показатель прогресса - работающий продукт
8) Постоянный ритм (взаимодействие всех сторон)
9) Техническое совершенство 
10) Простота (минимизация лишней работы)
11) Самоорганизация команды
12) Систематическая коррекция (анализ и корректирование)

## Билет №21

Scrum - гибкая методология разработки ПО.

Главными достоинствами является простота за счет упрощения числа административной работы.

Процесс разработки включает в себя: 
1) бэклог продукта и спринта - список требований с оценкой трудоемкости (по приоритету, отличия 1 от 2 - больший упор на общие требования без подробностей реализации)
2) инкремент продукта
3) спринт - период от 2 до 4 недель на реализацию выбранных требований, заканчивающийся демонстрацией 
4) владелец продукта - лицо, определяющее порядок требований в беклоге
5) скрам-мастер - лицо, отвечающее за планирование спринтов и команду
6) скрам-митинг - ежедневный митинг для отчетности и обсуждения целей к следующей встрече

## Билет №22

DAD - метод разработки ПО, построенный на принципах использования гибких методов типа RUP и Scrum. Отличительной особенностью является масштабируемость, что позволяет применять методологию для крупных проектов.

Включает в себя лучшие особенности RUP, Scrum и Agile. Также отличительной особенностью является управление процессами, но относящимися прямо к этапам разработки (управление, поддержка и т.п.)

## Билет №23

Требование - это условия или возможности, которым должна соответствовать система.

Требования должны быть однозначно определены и четко описывать, что должна выполнять система.
Требования описывают только общие условия к системе, без конкретных способов их реализации.

Способы реализации:
1) Модель требований (шаблон SRS - документ описания работы ПО, требований к нему - функциональных и нефункциональных)
2) Модель прецедентов (UseCase модель - описание в виде UML диаграммы)

### Иерархия требований

Иллюстрирует разделение требований по степени детализации: 
1) Потребности - примерные расплывчатые требования, предъявляемые заказчиком. Вместе с ними набор артефактов, иллюстрирующий начальное представление системы в их глазах
2) Функции - действия и возможности системы, которые формирует аналитик на основе потребностей заказчика. 
3) Требования к ПО - набор конкретно и четко сформулированных и согласованных с заказчиком функций и особенностей ПО.

![img_26.png](img_26.png)

## Билет №24

Свойства:
1) Корректность - однозначные и полные
2) Однозначность - без противоречий
3) Полнота - всеобъемлющее описание
4) Непротиворечивость
5) Приоритизация - по приоритетам
6) Проверяемость - наличие источника формирования требования
7) Модифицируемость - возможность изменения требования
8) Отслеживаемость - наблюдение за историей изменения требования

В RUP для описания требований используется модель FURPS+

Типы требований:
1) Функциональные (<система> shall <требование>)
2) Нефункциональные (характеристики и ограничения системы)

Нефункициональные:
1) Usability - требования к пользовательским хар-кам (пример - )
2) Reliability - требования к надежности системы (пример - число отказов в единицу времени)
3) Performance - требования к производительности (пример - время отклика)
4) Supportability - требования к поддержке (пример - способность обновлений без остановки системы)
5) Дополнительные - ограничения при построении архитектуры, требования к реализации, физические требования

## Билет №25

Формулируются требования на основе пожеланий заказчика согласно иерархии требований. 
Требование должно четко описывать действие или условие, которому удовлетворяет, но без особенностей и путей реализации.
Требование должно иметь порядковый номер, содержать имя системы или подсистемы.

### Функциональные требования

Определяют:
1) Feature Set (набор функ. требований) - набор свойств продукта для выполнения конкретной деятельности. 
2) Capability - возможности ПО
3) Security - требования к безопасности (описание ролей, аутентификации, шифрования)

## Билет №26

### Usability

Требования:
1) Человеческий фактор - особенности пользователя (спец. возможности)
2) Эстетические требования (цветовая палитра, корпоративный стиль), может отсутствовать
3) Подобность UI - единообразность подобных элементов
4) Справочная подсистема
5) Мастера настройки и ПО - упрощение последовательности действий пользователя для типовых задач
6) Пользовательская документация
7) Учебные материалы

### Reliability

Фиксирование способности ПО безотказно функционировать в течении определенного периода времени

Требования:
1) Частота и обработка отказов - от нее напрямую зависят требования к надежности. Определяет категории отказов по критичности, требования к их обработке и реакции системы
2) Способность системы восстановить продуктивное функционирование 
3) Предсказуемость поведения
4) Точность (например, вычислений)
5) Среднее время между отказами
6) Готовность системы к быстрому решению задач (реактивность) - обусловлено задержкой при переключении контекстов или особенности архитектуры

## Билет №27

### Performance

Требования:
1) Скорость решения задач (в системах реального времени и инженерных расчетах)
2) Эффективность - процент времени выполнения полезных задач по отношению к общему времени выполнения
3) Пропускная способность - обрабатываемый объем данных за единицу времени 
4) Время отклика 
5) Время восстановления 
6) Использование системных ресурсов

### Supportability

Требования:
1) Расширяемость - способность обработки большего объема данных, пользователей и т.д. 
2) Адаптируемость под конкретные задачи
3) Поддерживаемость - способность останавливать части системы без остановки обслуживания клиентов
4) Совместимость - поддержка и работоспособность на различных ОП, браузерах и т.д.
5) Способность функционирования при различных конфигурациях (различные функции в зависимости от задачи)
6) Профилактические работы
7) Установка на разные системы
8) Локализуемость

## Билет №28

Атрибуты помогают сортировать требования

1) Приоритет (MoSCOW) - обусловлено невозможностью реализовать все требования в короткий промежуток времени:
   1) must have - фундаментальные
   2) should have - важные
   3) could have - потенциально возможные
   4) won't have - могут быть в будущем
2) Статус:
   1) Предложенные
   2) Одобренные
   3) Отклоненные
   4) Включенные
3) Трудоемкость - количество ресурсов, необходимых на реализацию требования (имеет разные единицы измерения)
   1) Человеко-часы
   2) Функциональные точки
   3) попугаи
4) Риск - факторы, влияющие на разработку требования
5) Стабильность - частота изменения требований (высокая, средняя, низкая)
6) Целевая версия - версия, в которой планируется реализация требования

## Билет №29

Прецедент представлен блок-схемой с её атрибутами, потоками выполнения, актерами и условиями

![img_27.png](img_27.png)

Альтернативный поток - помеченный extend (расширение)
Встроить прецедент в поток - помеченный include

## Билет №30

Риски - это возможные опасные события, способные оказать влияние на разработку ПО

Их анализ - один из основополагающих процессов в цикле разработки

Типы рисков:
1) Прямые (управляемые в явном виде, с возможностью их контроля) и непрямые
2) Ресурсные (недостаток некоторого ресурса), управляемый
3) Бизнес-риски - взаимодействие с рынком и другими организациями (конкуренция, подрядчики), управляемый
4) Технические риски - находящиеся в пределах управления разработчиков (недостаток компетенции)
5) Политические риски - изменение сфер влияния внутри компании, неуправляемые
6) Форс-мажор - случайное событие, неуправляемое

## Билет №31

Управление рисками - деятельность, связанная с контролем, оценкой и управлением рисками

Оценка риска состоит из:
1) Первичная идентификация специалистом риска
2) Анализ риска
3) Составление плана работы (назначение приоритета, анализ по пунктам)

### Идентификация

Идентификация риска может быть неполной и неточной, т.к. слишком много путей их возникновения
Для точной идентификации используется схема идентификации на основе построения их источников
Распределение источников происходит по иерархической структуре

![img_28.png](img_28.png)

Первый уровень - классы рисков:
1) Риски разработки
2) Риски окружения разработки
3) Риски программного обеспечения

Второй уровень - элементы
Третий уровень - атрибуты

Риски также разделены на:
1) Известные (легко идентифицировать и определить)
2) Неизвестные (можно предположить место и момент появления)
3) Непознаваемые (невозможно предугадать место появления)

### Анализ

Подразумевает выявление скрытых источников риска и взаимосвязи их с определенными ситуациями

Существует несколько моделей и методов анализа:
1) Стоимостной - влияние риска при различных исходах
2) Сетевой - потенциальное взаимодействие между рисками
3) Качественных факторов - выявление источников и причин риска и построение их структуры

Основные параметры риска:
1) Вероятность наступления
2) Масштаб потерь

Задаются:
1) Нечетко
2) Мат. вероятностью или денежным эквивалентом
3) Шкала, разделенная по группам

### Приоритизация

Происходит по экспозиции риска - произведение вероятности возникновения риска на денежные потери.
Также во внимание берутся другие факторы, затем составляется список рисков.

## Билет №32

Контроль может осуществляться система контроля рисков, при вероятности наступления можно предпринимать действия по его корректировке

Контроль и управление риском состоит из:
1) Планирование управления и реакции на риск
2) Мониторинг
3) Разрешение неопределенности

Варианты реакции на риск:
1) Избегание - разработка комплекса мероприятий по отсрочке или исключения риска
2) Перенос риска - скидывание ответственности на другую сторону разработки
3) Сокращение вероятности риска - создание условий для минимизации возникновения риска
4) Прием риска - принятие риска и его мониторинг

### Разрешение риска

Мероприятия по не наступлению риска:
1) Прототипы (каждый новый прототип уменьшает возникновение риска)
2) Моделирование (построение модели функционирования ПО для сбора информации о риске)
3) Аналитическая работа (отработка ошибочных ситуаций для уменьшения вероятности возникновения рисков)
4) Подбор персонала

### Мониторинг

Ключевые моменты:
1) Анализ списка рисков во время разработки
2) Составление топ-10 списка рисков и его обновление
3) Переоценка рисков
4) Использование автоматизированных систем для обработки ошибок разработки и уменьшение вероятности возникновения риска

## Билет №33

Изменения - неотъемлемая часть любого цикла разработки. 
Управление ходом внесения изменений необходимо заниматься организованно, осуществляя строгий контроль.
Управление изменений - дисциплина по организованному контролю и управлению изменениями.
Под изменениями могут пониматься обновления не только кода, но и артефактов всех этапов разработки и т.д.

Под изменениями понимаются:
1) Новая функциональность
2) Нефункциональные требования
3) Исправление дефектов
4) Артефакты архитектуры, дизайна, анализа

Атрибуты:
1) Идентификатор
2) Дата
3) Ответственный
4) Описание
5) Журнал изменения

Общая модель управления изменениями - схема, иллюстрирующая получение, анализа, планирования, внедрения изменения

![img_29.png](img_29.png)
![img_30.png](img_30.png)
![img_31.png](img_31.png)

## Билет №34

VCS - инструменты управления изменениями в программном коде, дающие контроль над изменениями для группы разработчиков

Основные типы:
1) На основе файловой системы. Центральный сервис с общим доступом к файлам. Создавались файлы слежения за текущей директорией. Позволяло хранить и отслеживать версии в рамках одной файловой системы, экспортировать файловую систему для доступа удаленных клиентов при помощи сетевых файловых систем.
2) Централизованный. Единый репозиторий и удаленный доступ по специальным протоколам
3) Распределенный. Центральный репозиторий со скачиванием копии на локальный репозиторий, отправка после нескольких стадий проверки.

Примеры - Git, Subversion, CVS

Способы модификации файлов - lock-modify-unlock и copy-modify-merge

## Билет №35

SVN - централизованная система управления версиями.

Репозиторий - организованный иерархически набор файлов для удобной работы с проектом.
Каждая фиксация повышает версию репозитория на 1.

Архитектура построена на едином сервере, содержащем все версии файлов и наборе клиентов, загружающим данные с сервера. 
Хранение репозитория имеет 2 технические реализации: БД Berkley DB и файловая система.

Доступ к репозиторию осуществляется демоном svnserve, получающим команды от пользователя и выполняющий изменения в репозитории, или сервера Apache и его модулей.

Удаленный доступ - http+svn или ssh+svn

Клиент svn не только загружает и отправляет данные на сервер, но и управляет локальной копией файлов.

Общая структура следующая: 
1) Каталоги проектов
2) Директории для организации работы (trunk - основная разработка, branch - различные модификации, tag - функционально целостные изменения)
3) Файлы проекта

## Билет №36

Основной цикл разработки:
1) Получение изменений (svn update, checkout)
2) Изменить необходимые файлы (svn add, delete, copy, move, mkdir, status, diff, revert)
3) Фиксация изменений на сервере (svn update, merge, commit) 

## Билет №37

Конфликты делятся на:
### Конфликты содержимого файлов 
Изменение одного и того же участка кода.
Варианты разрешения конфликта:
1) edit - изменить в редакторе
2) resolved - разрешение конфликта в текущей версии файла
3) main(theirs)-conflict - подтвердить свои(чужие) версии файла для всех конфликтов
4) mine(theirs)-full - подтвердить версии полностью для своих(чужих) файлов
5) postpone - отложить на потом (создает 3 версии файла - до изменения, моя версия и удаленная)
6) launch - запуск внешнего средства

Помощь в разрешении:
1) diff-full - список несовпадений
2) display-conflict - все конфликты


### Конфликты структуры файлов
Разная структура файлов в локальной копии и удаленном репозиториях.
Разрешаются путем изменения структуры проекта на локальной копии

### Слияние изменений
Через svn merge <ветвь источника> <ревизия для интеграции> - подгружает изменения из веток в рабочую копию

## Билет №38

Построена по децентрализованному принципу - у каждого свой репозиторий, и изменения обновляют локальный репозиторий.
Делится можно частями репозитория (но почти не актуально)

### Архитектура

![img_32.png](img_32.png)

Центральный репозиторий также может быть исходным (при наличии прав доступа)

Stage Area - зона индексации

Способов отправки изменений - 2:
1) push
2) pull request - конфигурация запроса на фиксацию изменения владельцу ветки

### Основные команды
1) fork/pull request - создание удаленного репозитория/отправка изменений
2) clone/fetch/pull - клонировать репозиторий/получить изменения/получить изменения и слить с текущей веткой
3) rm --cached/reset HEAD - удаление файла из снимка при коммите/откат файла до состояния прошлого снимка

## Билет №39

1) Мажорные версии принято помечать тегом с номером версии
2) Ветка мастер - главная ветка разработки
3) develop - ветвь для разработки
4) feature - ветвь для определенного функционального требования
5) hotfix - ветвь для критических дефектов
6) release - тестирование и обработка релизных изменений

## Билет №40

Git flow - плагин, предоставляющий высокоуровневые операции над репозиторием
Особенность - работа не в терминах git, а в терминах веток ПО

![img_33.png](img_33.png)

## Билет №41

Система сборки - средство для автоматической сборки. Используют специальный язык, которым описывают, что действия для системы сборки.
Позволяют задать конфигурацию системы и автоматически определить архитектуру.
Поддерживают параллельный режим сборки, некоторые - многомашинные. Интегрируются со сборочными серверами и автоматическими тестами.

Условно делятся на императивные (как собирать) и декларативные (что собирать).

Неудобства:
1) Рутинный процесс сборки (сложно поддерживать в актуальном состоянии, все руками)
2) Отличия архитектур (отличия аппартного обеспечения и операционной системы)
3) Медленная сборка (много файлов, нет параллелизма)

## Билет №42

Make - средство сборки низкого уровня. В Unix-подобных системах. Файл сборки - Makefile. 

Шаблон собираемой цели:
<цель>: <зависимости>\
      <команда>

Возможно указать макропеременные(вначале файла). Идет анализ со стандартной цели all, затем сборка по зависимостям

Неудобен вследствие необходимости следить за большим числом переменных и действий

## Билет №43

Императивная система сборки. Управляется файлом сборки build.xml (на основе xml). 

Цели указываются через \<target name="...">.
Зависимости - через атрибут depends
Вызвать зависимости - через \<antcall target="..."> возможно из другого файла

Свойства конфигурации задаются через:
1) Значения - \<property name="..." value="">
2) Переменные окружения - \<property environment="env">
3) Из файла - \<property file="...">

Минимальный набор команд:
1) echo – вывод сообщений в консоль 
2) mkdir – создание директорий 
3) delete – удаление файлов и директорий 
4) javac – компиляция Java–кода 
5) java – запуск class и jar файлов 
6) jar – создание jar файла 
7) junit – запуск тестов

Преимущества команд ant перед обычными командами в терминале - платформонезависимость 

## Билет №44

Ant ivy - расширение для управления внешними зависимостями. Позволяет добавлять их в путь к классам, объединять в сборку и т.д.

Обеспечивает гибкость и конфигурируемость, т.к. не зависит от процесса и не привязан к структуре.
Интеграция с ant.
Позволяет получать зависимости зависимостей - управление транзитивными зависимостями

Подключение : \<ivy-module>

Имеет свой файл ivy.xml для задания зависимостей (задаются как в основном build.xml)

## Билет №45

Maven - система сборки декларативного подхода (что собираем, не как). Процесс сборки осуществляется логикой плагинов.

Project Object Model (POM) - xml-файл с информацией о проекте и подробностях конфигурации:
1) Имя проекта
2) Путь к исходному коду
3) Зависимости
4) Плагины (средства для разработки)
5) Профили (альтернативные конфигурации проекта)

Отличительная черта - организация центрального репозитория библиотек. Процесс сборки:
1) Описание зависимостей проекта
2) Вызов maven install
3) Чтение POM
4) Проверка зависимостей в центральном репозитории
5) Загрузка необходимых, помещая в локальный репозиторий (для экономии трафика)
6) При компиляции - передача maven 
7) После компиляции - запись исходников в локальный репозиторий и директорию target

Сборка по умолчанию - последовательная (можно распараллелить)

## Билет №46

maven определяет строгий набор директорий для организации структуры проекта. Можно собрать автоматически через плагины

Структура проекта:
1) target - рабочая и целевая директория (скомпилированные файлы, временные файлы, целевые версии сборки)
2) src/main - основные исходные файлы
   1) main/java - исходники java
   2) main/webapp - web-страницы, jsp, js, css
   3) main/resources - некомпилируемые файлы
3) src/test - исходники для тестов
   1) java
   2) resources

GAV - принцип наименования модулей и внешних зависимостей в maven (groupId:artifactId:version).

\<groupId><groupId\>\
\<artifactId><artifactId\>\
\<version><version\>

Модуль хранится в m2 директории (локальный репозиторий) по пути:
{groupId}/{artifactId}/{version}/{artifactId}-{version}.jar

Преимущество такого способа - организация в виде иерархического дерева

## Билет №47

Зависимости описываются GAV-синтаксисом и скачиваются автоматически. 
Кроме GAV-параметров, у зависимости существует scope (область видимости, по умолчанию - compile) - этап жизненного цикла, в который применяется данная зависимость.

Все области:
1) compile - при компиляции 
2) provided - во время размещения в исполняемом контейнере 
3) runtime - при выполнении 
4) test - во время тестирования
5) system - аналогична provided за исключением ее содержания в jar

type (цель сборки):
1) jar - исполняемый архив java
2) pom - создание родительского или многомодульного проекта 
3) war - исполняемый web-архив
4) ear - архив корпоративных приложений (содержит war и jar, запуск на сервере)
5) zip - архив с сжатыми файлами

Зависимости транзитивны - зависимости распространяются с дочерних контейнеров на родительский 

### Жизненный цикл
Это последовательность сборки приложения
1) generate-source/generate-resource - автогенерация исходного кода (если необходимо)
2) compile
3) test-compile
4) test
5) package
6) integration-test
7) install - установка на локальный репозиторий
8) deploy - развертывание приложения на указанном сервере

### Плагины

Это средства для разработки, управляющие сборкой проекта (все операции управляются ими).
Явно включаются в pom.
Каждый плагин имеет точки входа, связанные с ЖЦ (упаковка, очистка, развертывание и т.д.)

## Билет №48

1 в 1 билет №46, возможно тут должно быть про gradle

## Билет №49

GNU autotools - платформонезависимая система автоматизации сборки. 

Генерирует make файл на основании конфигурации системы, ОП и используемых библиотек.
Решает проблему конфигурации системы. Не скачивает удаленные зависимости.

Основан на макропроцессоре (программа, преобразующая входной текст в выходной, руководствуясь правилами замены последовательности символов(правила макропроцессора)) общего назначения m4.
Используется для открытого ПО.

Команды для сборки:
1) ./configure
2) make
3) sudo make install

### Конфигурация проекта
![img_34.png](img_34.png)
1) Исходный код с помощью утилиты autoscan сканируется на участки кода с возможными зависимостями от ОП или платформы и добавляет в configure.scan
2) configure.scan корректируется вручную и получается configure.ac
3) Создается (в каждом из подкаталогов) Makefile.am с зависимостями и исполняемыми программами
4) autoheader создает из Makefile.am и configure.ac шаблон config.h.in для config.h(платформозависимые особенности)
5) aclocal проверяет configure.ac на недостающие библиотеки и зависимости и генерирует aclocal.m4
6) automake собирает из config.h.in, Makefile.am, configure.ac Makefile.in (шаблон для Makefile для сборки) 
7) autoconfig собирает из configure.ac и aclocal.m4 configure

Оба файла используются для определения текущей конфигурации на целевой системе.

## Билет №50

Конфигурация configure.ac содержит описание продукта(имя, версия, путь к исходникам и заголовкам).
Затем проверяется наличие компилятора и системных библиотек, отдельных в них функций. 
При конфигурации будут создаваться тестовые программы, тут же компилируемые и проверющие наличие необходимых библиотек.
Имеющиеся будут указаны в config.h

Зависимости Makefile.am описывает исходники, названия модулей, ключи для каждого каталога сборки.

### Конфигурация
![img_35.png](img_35.png)
1) ./configure из config.h.in и Makefile.in создает config.h и Makefile(платформозависимые файлы)
2) make собирает файлы
3) make install размещает файлы в системных каталогах

Системные каталоги ./configure можно изменить

## Билет №51

Для многократной автоматической сборки удобнее использовать сервера сборки (непрерывной интеграции).
Основное назначение - сборка новой версии продукта при заданных условиях (например - обновление ветки мастер).
Также могут проводить тесты, снимать метрики, автозапуск и т.д. Предоставляет доступ к скачиванию любой версии продукта(через интерфейс).
Пример - Jenkins

## Билет №52

Терминология отрицательных ситуаций:
1) Mistake
2) Fault - дефект (результат ошибки)
3) Failure - отказ вследствие дефекта
4) Error - невозможность выполнить задачу
5) Bug - следствие внешнего фактора

Цели тестирования:
1) Обнаружение дефектов
2) Повышение уверенности в уровне качества
3) Предоставление информации для принятия решения
4) Предотвращение дефектов

Никакое тестирование не гарантирует отсутствие ошибок и дефектов.

Главная и наиболее точная цель - повышение уровня доверия пользователя к ПО в плане работоспособности при необходимых обстоятельствах.
Составные части цели:
1) Корректное поведение - соответствие требованиям
2) Пользовательское доверие - через метрики уровня дефектов
3) Требования реального окружения - условия тестирования, приближенные к реальным

## Билет №53

Тестовое покрытие - понятие, описывающее плотность покрытие исполняемого кода программы тестами для поиска дефектов и уязвимостей.
Полное тестовое покрытие - покрытие тестами всех возможных вариантов развития событий и всего кода. Достижимость сомнительна, т.к. слишком большие временные затраты и затраты памяти

ПРИГОТОВИТЬ ПРИМЕР!!!

Самый удобный способ тестирования - таблица с входными данными и эталонным значением. Эталонной считается в отрыве от тестируемого.

### Пример тестирований для V-chart
![img_36.png](img_36.png)

Валидация - мероприятия по проверке корректности требований.
Верификация - проверка ПО на соблюдение требованиям

## Билет №54

Тестирование делится на 2 вида: 
1) Статическое - подразумевает рецензирование (без исполняемого кода). Подразумевает ручное или автоматизированное рецензирование кода, неформальные проверки(митинги), сквозной контроль(упорядоченная проверка оборудование и кода), инспекция 
2) Динамическое - проверка работоспособности кода (запуск модулей, групп модулей, системы)

Подход TDD(Test Driven Development) подразумевает написание тестового покрытия на основе требований и написание кода под тесты

## Билет №55

Автоматизация тестов - процесс автоматического создание и выполнения тестов для экономия времени и ресурсов

Не всегда необходимо автоматизировать тесты. (проще и дешевле)

Под автоматизацию подходит регрессионное - запуск старых тестов после внесения изменений

Для обеспечения автоматизации и регрессионного тестирования нужно обеспечить однозначное повторение тестового сценария

Необходимо проводить тестирование в разных окружениях (тестирование совместимости).
Это зачастую вызывает наибольшие трудозатраты.

Автоматизация может использоваться как проверка перед приемочным тестированием (обычно проводится вручную)

## Билет №56

Источники:
1) Описание ПО (метод черного ящика) - спецификация, требования, дизайн, запуск и сравнение с эталонными
2) Исходный код (метод белого ящика) - переходы, утверждения, условия, анализ путей и структур (сложность - ориентирование и покрытие). Позволяет оценить тестовое покрытие через создание графа, представляющего код через узлы, переходы и т.д. Далее через цикломатическую сложность можно оценить количество необходимых тестов. Тесты должны покрывать все пути графа
3) Опыт
4) Модели - UML

Деятельности и роли:
1) Проектирование - (на основе критериев формируют тестовое покрытие)
2) Автоматизация - (знание средства, скриптов)
3) Исполнение - (нет спец требований)
4) Анализ - (знание предметной области)

## Билет №57

Тестовый случай - набор входных данных, пред и пост условий и ожидаемых результатов 

Входные значения - данные или управляющие значения с определенным поведением ПО

Пред и пост условия, условия выполнения

Ожидаемый результат - выходные данные и состояния, изменения в них. Должны быт определены до запуска теста

Характеристики тестового случая:
1) Повторяемый (одинаковые входные дают тот же выход)
2) Автоматизируемый
3) Учитывает состояние (правильные и неправильные переходы)

Тестовые случаи - не только верные, но и приводящие к ошибке

Тестовый сценарий - последовательность тестовых случаев. Предусматривают как положительные, так и отрицательные реакции системы

## Билет №58

Выбор тестового покрытия - с помощью методов:
1) Эквивалентное разбиение - анализ граничных значений
2) Таблица решений - таблица соответствующих входных данных и выходных
3) Таблица переходов - выделение состояния и переходов для их покрытия тестами
4) Сценарии использование - usecase с конкретными входными данными

Выбор числа тестов - на балансе:
1) Много тестов - больше покрытие - выше качество
2) Меньше тестов - быстрее разработка - быстрее релиз

Анализ эквивалентности - метод выбора тестового покрытия на основе разбиения программы на модули, внутри которых программа ведет себя одинаково.
Для каждого участка пишется некоторое количество тестов.

## Билет №59

Модульное тестирование - тестирование отдельных компонентов ПО (модули, классы, их совокупность)

Описание модулей - в дизайн. доке

Для тестирования необходимо изолировать модуль от системы ради исключения сторонних воздействий. 

Вызывающие модули заменяются драйверами (компонент, вызывающий модуль и обеспечивающий последовательность тестирования), вызываемые - заглушками(тот же api, но с упрощенной логикой и заранее определенным возвратом).
Для этого может понадобиться отдельная тестовая сборка приложения.

### JUnit4

Это фреймворк для производства тестирования java. Через аннотации организует маркировку.

Основные аннотации:
1) @Test - метод как тест, ищется через рефлексию и запускается
2) @Before, After, BeforeClass, AfterClass - метод пред и пост условий, исполняемый до, после каждого теста и до и после класса тестов.

assertion - функция проверки на условия теста.

Последовательность вызова тестов не регламентирована, фреймворк сам ее определяет

## Билет №60

Интеграционное тестирование - тестирование взаимодействия между модулями (вызов api, взаимодействия между компонентами, интерфейсы взаимодействия, UI, БД, интерфейсы)

Является следующим шагом после модульного тестирования

Используется после разработки компонентов

Проверяет правильность последовательности вызовов и соответствие протоколов

Бывает системным, когда проверяется взаимодействие системных компонентов или аппаратного обеспечения

Последовательность реализации модулей и их проверки определяется стратегией интеграции.

Стратегии:
1) сверху вниз - проверка от бизнес-логики, затем с подключением UI, затем уровень хранения(много заглушек, но быстро для демонстрации)
2) снизу вверх - проверка с блоков нижнего уровня(для систем с тесной аппаратной связанностью)
3) Функциональная - тестирование модуля полной цепочки (ui-bl-бд)
4) Ядро - создание и тестирование минимального функционала, затем расширяем
5) Большой взрыв - все сразу и молимся

## Билет №61

Функциональное тестирование - тестирование на базе сценариев использования, проверяет функционал, заложенный в ПО.
Проверка начинается с GUI, могут выполняться как вручную, так и автоматизированно средствами взаимодействия.
Тестируемый функционал должен быть завершен на всех этапах.
Зачастую полностью автоматизировать невозможно.

Selenium - средство автоматизации проверка GUI. Берет на себя управление интерфейсом, записывая сценарий выполнения, который затем сохраняется в виде тестовой программы

## Билет №62

Статическое тестирование - тестирование, проводимое перед началом динамического тестирования. 
Особенность - нахождение дефектов, не их последствий(отказов). Позволяет находить ошибки на ранних стадиях разработки (например - в спецификации), снижает риски.
Что тестируем - стратегии, плане, задания, спецификации и т.д.

Преимущества:
1) Улучшение продуктивности разработки
2) Уменьшение времени и стоимости разработки
3) Уменьшение времени и стоимости тестирования
4) Уменьшение числа дефектов
5) Улучшение коммуникации в команде

Методы:
1) Рецензия
2) Технический анализ - ревью другими людьми по метрикам
3) Сквозной контроль - презентация кода
4) Инспекция - выбор инспекторов
5) Management review - оценка системы управления

Средства - FindBugs (Java) - неопределенное поведение, нарушение алгоритмов использования, переполнение буфера и т.д.

## Билет №63

Тестирование системы в целом - тестирование по проверке заявленных характеристик. 
Проводится после интеграционного. 

Этапы:
1) Системное - внутри организации разработчика, проверяет нефункциональные требования
2) Альфа (с целевой группой внутри окружения разработчиков) и Бета (система в пользовательской среде) тестирования - с подключением пользователя под контролем разработчиков
3) Приемочное - полностью в управлении и среде пользователя

Методики одинаковые, различается строгость интерпретация 

Порядок тестирования (от простого к сложному):
1) Заявленные возможности ПО
2) Стабильность системы - различные условия
3) Устойчивость к сбоям
4) Совместимость системы
5) Производительность

Тестирование производительности включает в себя все виды тестов по CARAT:
1) Capacity(нефункциональные возможности) - нефункциональные требования
2) Accuracy(точность) - точность производимых вычислиней и расчетов
3) Response Time(время ответа) - на запрос
4) Availability(готовность) - (время до отказа - время до восстановления)/(время до восстановления)
5) Throughput(пропускная способность) - запросов за единицу времени

Нагрузочное тестирование можно проверить с помощью продуктов генерации нагрузки. Широкий выбор протоколов, статистическая и динамическая нагрузка

Для java - Apache JMeter

## Билет №64

Альфа (с целевой группой внутри окружения разработчиков) и Бета (система в пользовательской среде) тестирования - с подключением пользователя под контролем разработчиков

## Билет №65

### Системный и архитектурный

1) Архитектура системы, её внутренних блоков, их взаимодействия 
2) Виртуализации (представление выч. ресурсов абстрагировано от аппаратной реализации) и кластеризации

### Низкоуровневый аппаратный

1) Характеристики процессора
2) Характеристики памяти и ее организация (кэш, память, диски и т.д.)

### Программный

1) Используемые алгоритмы и структуры данных
2) Параллелизм (пулы, потоки, блокировки)

### Человеческий фактор

1) Ошибки

### Влияние средств наблюдения зависит от:
1) Критериев оценки
2) Средства измерения (неинтрузивные, слабоинтрузивные, интрузивные)
3) Выбрать нагрузку или нагрузить ею систему (должна быть эквивалентной настоящей)
4) Провести анализ результатов ()
5) Провести изменения по оптимизации (менять небольшое число параметров)
6) Повторять начиная с 3) до полного удовлетворения

## Билет №66

1) Время отклика - время от выдачи запроса до получения первого результата
2) Полное время обслуживания - от выдачи запроса до получения полного результата
3) Пропускная способность - максимальное число запросов за единицу времени
4) Утилизация ресурса (%util) - доля полезной работы ресурса
5) Ожидание (%wait) - доля ожидания ресурса
6) Точка насыщения - предельная нагрузка
7) Масштабируемость - возможность расширить и нагрузить систему
8) Эффективность - отношение полезной работы к общей работе
9) Прирост производительности - увеличение полезной работы после изменений

## Билет №67

Метод для поиска мест, мешающих дальнейшему повышению производительности. Последовательно рассматривает систему от более общих компонентов к более частным:
1) Ошибки аппаратуры и администратора (системные журналы, файлы конфигурации, прикладное ПО). Пример - сбойный блок на диске 
2) Общесистемный и межузловой мониторинг (используются счетчики производительности CPU, I/O, сети, ОС)
3) Мониторинг приложения (алгоритмы, проблемы API, многопоточность)
4) Мониторинг микроархитектуры (оптимизация кэшей, выравнивание данных под кэш)

## Билет №68

Пирамида памяти - сущность, описывающая используемые в вычислительно системе типы памяти.

Тип используемой памяти может серьезно повлиять на быстродействие программы.

![img_37.png](img_37.png)

## Билет №69

Системный мониторинг - это производство контроля за системными ресурсами.

Осуществляется при помощи средств ОС. Позволяет получать и анализировать различные параметры ОС и запущенных программ.

Для мониторинга CPU важно знать количество процессов на уровне пользователя, затраты CPU на эти ресурсы, время простоя, переключение контекста(context_switch), прерывание(interrupt), средняя загрузка очереди исполнения(load average).

ОС может предоставить данные других подсистем(статистика ядра)

Обычно такой мониторинг неинтрузивен(не влияет на работоспособность системы).

![img_38.png](img_38.png)

Результат диспетчеризации контролируется системными утилитами

Состояния процесс или потока:
1) Runnable - готов к исполнению
2) On CPU User/Sys - на исполняющем устройстве или уровне пользователя
3) Wait - ожидание

Пояснения к рисунку - раз в 10 секунд происходит прерывание от часов (clock interrupt) с наращиванием счетчика производительности, проверкой очереди на процесс с большим приоритетом и кванта времени текущего.
При вызове к IO устройству происходит переход процесса в ожидание и происходит смена потока (context switch).
Выбирается процесс с большим приоритетом, повышается приоритет ожидаемого, а ожидаемый становится исполняемым. 

## Билет №70

Виртуальная память - метод управления памятью компьютера с использованием автоматического перемещения данных между основной памятью и вторичными хранилищами.  

Для мониторинга виртуальной памяти отслеживается количество немедленно готовой свободной памяти(free), объем занятых буферов(buff) и кэшей(cache), количество читаемых(pagein/s) и записываемых(pageout/s) системой страниц, скорость сканирования измененных страниц(scantime).

![img_39.png](img_39.png)

Пояснения: задействованы физическая память, устройство подкачки на диск(swap-устройства) и виртуальные страницы.
Страница может быть в памяти, на swap-устройстве или зарезервированной(необходима, но еще не используется).
Память процесса делится на страницы от 2Мб до 4Кб.
Количество мэппингов(записей отображений структуры виртуальных адресов ОС на страницы внутри банка памяти) зависит от размера страниц.
Данные также можно не перемещать, а просто стереть (т.к. могут загружаться из файла программы).
Страницы, связанные с файлами - именованные, динамически созданные в куче - анонимные.


Процессы с памятью:
1) Scan rate - просканированные страницы за единицу времени (чем больше, тем острее недостаток памяти)
2) При недостатке происходит сканирование редко используемых и неизменяемых страниц и либо записывается на диск, либо удаляется.
3) При обращении к несуществующей странице происходит страничный сбой(page fault). Минорный - если нужно создать запись в таблице адресации или существенный, когда ее надо подгрузить из диска подкачки.

Сбор статистики (Unix) - через sar -B

## Билет №71

Для мониторинга подсистемы IO необходимо знать скорость чтения и записи в секунду и число операций для их осуществления.
Wait time - параметр времени ожидания до получения первых данных.

![img_40.png](img_40.png)

Пояснения: организация буферизованного IO. При чтении вначале указывается количество байт для чтения(IO record size). 
Интенсивность определяется требованиями программы.


При обращении к функции чтения/записи формируется обращение к ядру и вызывается соответствующая функция ядра.
В ядре вызов попадает в VFS(virtual file system) и передается на уровень не конкретной файловой системы.
Имя файла преобразуется в DNLC(directory name lookup cache - кэш, ускоряющий работу имен файлов) в номер файла inode в необходимой файловой системе. 
Для экономии ресурсов операция будет работать в первую очередь с буферным кэшем.
В нем данные хранятся в виде блоков данных в ОЗУ, формируя промежуточное хранилище.
Каждый некоторый момент времени помеченные как измененные данные сохраняются на диске.
Под VFS находится реализация модулей ядра физических файловых систем.
На уровне аппаратного интерфейса данные перемещаются на диск, а работу на себя берет драйвер???

Параметры для каждой файловой системы:
1) Количество чтений r/s
2) Количество записей w/s
3) Объем читаемых данных rkB/s
4) Объем записываемых данных wkB/s
5) Среднее время запроса avgrq-sz
6) Время ожидания await
7) Время обслуживания svctm
8) Процент занятости устройства util

Вырожденные типы обмена с дисковой подсистемой:
1) Случайный доступ (каждый запрос - к новому месту диска) - скорость повышается ssd
2) Последовательный (чтение и запись - последовательно) - скорость сильно выше случайного доступа

Сбор статистики - iostat

## Билет №72

### Windows
Самый распространенный - Task Manager (статистика использования процессора, памяти, дисковой подсистемы и т.д.)
Более детальный - Resource Monitor & Performance Monitor, Reliability Monitor.
Еще более детальную - Microsoft SysInternals, базирующийся на внутрисистемных счетчиках, показывая более точные результаты.

### Linux
Большое количество средств мониторинг за подсистемами с учетом особенностей архитектуры. 
В большинстве они неинтрузивны.

![img_41.png](img_41.png)

На рисунке - вызовы для каждой подсистемы

Стандартные средства мониторинга:
1) vmstat - информация по виртуальной памяти
2) mpstat - информация по нагрузке на CPU
3) iostat - информация по IO
4) top - динамическое наблюдение за запущенными процессами 
5) sar - вывод различной системной информации ядра
6) perf - sar + запущенные программы + счетчики производительности
7) strace - наблюдение за процессом, проводя трассировку системных вызовов. Достаточно интрузивен
8) stap - установка точек сбора информации о ядре, его подсистемах

## Билет №73

Последовательность:
1) upload - средняя загрузка процессорной подсистемы за 1, 5 и 15 минут
2) dmesg|tail - последние ошибки
3) vmstat 1 - виртуальная память
4) mpstat -P ALL 1 - распределение процессов на CPU
5) pidstat 1 - наиболее затратные процессы
6) iostat -xz 1 - характеристики IO
7) free -m - проверка кэшей, буферов
8) sar -n DEV 1 - сетевая статистика по интерфейсам и соединениям
9) top - сочетает все команды выше

## Билет №74

Из-за возможного внесения в работу ПО изменений при работе с средствами мониторинга, создают тестовую систему (копию текущей) и мониторинг проодят на ней.
Такая система позволяет использовать интрузивные средства нагрузки, а также создавать близкую к реальной нагрузку.
Такие нагрузки создаются средствами синтетической нагрузки или записи реальной нагрузки, которую потом можно использовать.
В средствах создания больше гибкости в мониторинге.

## Билет №75

Профилирование - процесс исследования приложения для выявления дефектов.

Для этого есть профилировщики. Дают информацию о времени исполнения, объеме созданных объектов, потоках и времени ожидания освоюождения блокировок и т.д.

Подходы:
1) Внедрение точек диагностики в сами функции. Интрузивен
2) Прерывание программы с периодичностью. Во время прерывания - сбор информации. Для определения времени исполнения - состояние стека в момент прерывания, для характеристик - сбор инфы о куче.

Интервал - середина между слабой интрузивностью и мониторингом мельчайших процессов

## Билет №76

Компромиссы (trade-offs) - уступки, принимаемые в борьбе за производительность.
Пример - чем быстрее доступ к памяти, тем больше требуется места. 
Другой - больший кэш быстрее чтения/записи, но крайне ограничен.
Алгоритмы оптимизируют по скорости, давай проигрыш в памяти

## Билет №77

Фиксы высокой загруженности CPU:
1) Высокая нагрузка на IO (уменьшить частоту чтения/записи, реже сжимать файлы)
2) Недостатки работы планировщика (частая диспетчеризация, возможно слишком много потоков)
3) Избыточная подкачка страниц (проблемы с виртуальной памятью, можно выдать больше памяти системе или отгружать данные на диск)
4) Трата процессорного времени в других функциях (исключить лишние процессы, настроить параметры ядра)

## Билет №78

Высокое время ожидания CPU:
1) Проблемы приложения (оптимизация запросов к диску, уменьшить число обращений)
2) Мало места под промежуточные хранилища (расширить кэш и буфер)
3) Проблемы с аппаратурой (новая дисковая система)

## Билет №79

Высокое время простоя CPU:
1) Мало процессов выполняются (распараллелить, оптимизация пулов через добавление новых потоков) или внутренние блокировки (меньше держать блокировку, алгоритмы без блокировки)
2) Проблемы ОС (проверка блокировок, настройка подсистем ядра, поиск в багтрекере дефектов)

## Билет №80

Для поиска - профилировщики

Высокое время выполнения пользовательских приложений:
1) Использование более простых алгоритмов (помним о компромиссах)
2) Повторное использование объектов (новые данные закинуть в объект)
3) Избавление от кэш промахов (исправить попадание данных в одну строку кэша). Для минимизации запроса можно биндить потоки за процессами  